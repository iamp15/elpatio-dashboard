---
description: Convenciones y estÃ¡ndares especÃ­ficos para el Dashboard de El Patio, con Ã©nfasis en modularidad y separaciÃ³n de responsabilidades
globs: ["elpatio-dashboard/**/*.jsx", "elpatio-dashboard/**/*.js", "elpatio-dashboard/**/*.css"]
alwaysApply: false
---

# Dashboard - El Patio - Convenciones de Modularidad

## ğŸ¯ Principio Fundamental: Modularidad y SeparaciÃ³n de Responsabilidades

**La modularidad es la base de un cÃ³digo mantenible y escalable.** Este documento establece reglas estrictas para evitar archivos monolÃ­ticos y asegurar que cada mÃ³dulo tenga una Ãºnica responsabilidad clara y bien definida.

## âš ï¸ Reglas CrÃ­ticas de Modularidad

### 1. LÃ­mite de TamaÃ±o de Archivos

- **LÃMITE ABSOLUTO: 400 lÃ­neas por archivo** (incluyendo comentarios y espacios en blanco)
- **LÃMITE RECOMENDADO: 250 lÃ­neas por archivo**
- Si un archivo supera las 400 lÃ­neas, **DEBE dividirse inmediatamente**
- No hay excepciones a esta regla - es obligatoria

### 2. Responsabilidad Ãšnica

**Cada archivo debe tener UNA y SOLO UNA responsabilidad:**

- âŒ **NO** mezclar lÃ³gica de negocio con lÃ³gica de presentaciÃ³n
- âŒ **NO** combinar manejo de estado con llamadas a API
- âŒ **NO** incluir mÃºltiples utilidades no relacionadas
- âŒ **NO** tener componentes que manejen varios contextos diferentes
- âœ… **SÃ** crear un archivo separado para cada responsabilidad
- âœ… **SÃ** usar composiciÃ³n para combinar funcionalidades

### 3. Estructura Modular Obligatoria

Cada mÃ³dulo debe seguir esta estructura estricta:

```
modulo/
â”œâ”€â”€ componentes/        # Componentes React (uno por archivo)
â”‚   â”œâ”€â”€ ComponenteA.jsx
â”‚   â”œâ”€â”€ ComponenteA.css
â”‚   â”œâ”€â”€ ComponenteB.jsx
â”‚   â””â”€â”€ ComponenteB.css
â”œâ”€â”€ hooks/             # Custom hooks (uno por archivo)
â”‚   â”œâ”€â”€ useCustomHook.js
â”‚   â””â”€â”€ useAnotherHook.js
â”œâ”€â”€ servicios/         # Servicios y API (uno por responsabilidad)
â”‚   â”œâ”€â”€ servicioA.js
â”‚   â””â”€â”€ servicioB.js
â”œâ”€â”€ utilidades/        # Funciones de utilidad (agrupadas por propÃ³sito)
â”‚   â”œâ”€â”€ formatters.js  # Solo funciones de formateo
â”‚   â”œâ”€â”€ validators.js  # Solo funciones de validaciÃ³n
â”‚   â””â”€â”€ constants.js   # Solo constantes
â””â”€â”€ tipos/             # Tipos TypeScript (si aplica)
    â””â”€â”€ tipos.ts
```

## ğŸ“‹ Estructura del Proyecto Dashboard

```
elpatio-dashboard/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/        # Componentes reutilizables
â”‚   â”‚   â”œâ”€â”€ layout/       # Componentes de layout
â”‚   â”‚   â”‚   â”œâ”€â”€ MainLayout.jsx
â”‚   â”‚   â”‚   â””â”€â”€ MainLayout.css
â”‚   â”‚   â””â”€â”€ ui/           # Componentes UI bÃ¡sicos
â”‚   â”‚       â”œâ”€â”€ Badge.jsx
â”‚   â”‚       â”œâ”€â”€ Badge.css
â”‚   â”‚       â”œâ”€â”€ Button.jsx
â”‚   â”‚       â””â”€â”€ Button.css
â”‚   â”œâ”€â”€ pages/            # PÃ¡ginas de la aplicaciÃ³n
â”‚   â”‚   â”œâ”€â”€ Dashboard.jsx
â”‚   â”‚   â”œâ”€â”€ Dashboard.css
â”‚   â”‚   â””â”€â”€ [otras-paginas]
â”‚   â”œâ”€â”€ hooks/            # Custom React hooks
â”‚   â”‚   â”œâ”€â”€ useWebSocket.js
â”‚   â”‚   â”œâ”€â”€ useStats.js
â”‚   â”‚   â””â”€â”€ useAuth.js
â”‚   â”œâ”€â”€ services/         # Servicios externos
â”‚   â”‚   â”œâ”€â”€ api.js        # Llamadas a API REST
â”‚   â”‚   â”œâ”€â”€ auth.js       # Servicio de autenticaciÃ³n
â”‚   â”‚   â””â”€â”€ websocket.js  # Servicio de WebSocket
â”‚   â”œâ”€â”€ utils/            # Funciones de utilidad
â”‚   â”‚   â”œâ”€â”€ formatters.js # Formateo de datos
â”‚   â”‚   â”œâ”€â”€ validators.js # Validaciones
â”‚   â”‚   â””â”€â”€ constants.js  # Constantes compartidas
â”‚   â””â”€â”€ App.jsx           # Componente raÃ­z
```

## ğŸ§© Componentes React

### Reglas para Componentes

1. **Un componente por archivo**
   - Cada componente debe estar en su propio archivo
   - El nombre del archivo debe coincidir con el nombre del componente (PascalCase)

2. **TamaÃ±o mÃ¡ximo de componente: 300 lÃ­neas**
   - Si un componente supera 300 lÃ­neas, debe dividirse:
     - Extraer subcomponentes
     - Mover lÃ³gica a custom hooks
     - Mover lÃ³gica de negocio a servicios

3. **SeparaciÃ³n de responsabilidades en componentes**
   - **PresentaciÃ³n**: Solo renderizado y UI
   - **LÃ³gica**: Extraer a hooks o servicios
   - **Estado local**: Solo para estado especÃ­fico del componente
   - **Estado global**: Usar hooks o context API

### PatrÃ³n de Componente Modular

```jsx
// âœ… BIEN: Componente pequeÃ±o y enfocado
import { useState } from 'react'
import { formatCurrency } from '../../utils/formatters'
import Card from '../ui/Card'
import './DashboardCard.css'

/**
 * Componente para mostrar una tarjeta de estadÃ­stica
 * @param {Object} props
 * @param {string} props.title - TÃ­tulo de la tarjeta
 * @param {number} props.value - Valor a mostrar
 * @param {string} props.icon - Icono emoji
 */
function DashboardCard({ title, value, icon }) {
  return (
    <Card className="dashboard-card">
      <div className="dashboard-card-icon">{icon}</div>
      <div className="dashboard-card-content">
        <h3>{title}</h3>
        <p className="dashboard-card-value">{formatCurrency(value)}</p>
      </div>
    </Card>
  )
}

export default DashboardCard
```

### âŒ Anti-Patrones a Evitar

```jsx
// âŒ MAL: Componente que hace demasiado
function Dashboard() {
  // âŒ Maneja carga de datos
  const loadData = async () => { /* ... */ }
  
  // âŒ Maneja WebSocket
  const setupWebSocket = () => { /* ... */ }
  
  // âŒ Formatea datos
  const formatCurrency = (amount) => { /* ... */ }
  
  // âŒ Valida datos
  const validateData = (data) => { /* ... */ }
  
  // âŒ Maneja mÃºltiples estados
  const [stats, setStats] = useState(null)
  const [connection, setConnection] = useState(null)
  const [errors, setErrors] = useState(null)
  // ... muchos mÃ¡s estados
  
  // âŒ Renderiza mucho JSX
  return (
    <div>
      {/* Mucho cÃ³digo JSX */}
    </div>
  )
}

// âœ… BIEN: Componente dividido en mÃ³dulos mÃ¡s pequeÃ±os
// Dashboard.jsx - Solo orquestaciÃ³n
// useDashboardData.js - Hook para carga de datos
// useWebSocketConnection.js - Hook para WebSocket
// DashboardStats.jsx - Componente para estadÃ­sticas
// DashboardConnection.jsx - Componente para estado de conexiÃ³n
```

## ğŸ£ Custom Hooks

### CuÃ¡ndo Crear un Custom Hook

Crear un custom hook cuando:
- âœ… La misma lÃ³gica se reutiliza en mÃºltiples componentes
- âœ… Un componente tiene mÃ¡s de 3 `useState` o `useEffect`
- âœ… Hay lÃ³gica compleja que debe separarse del componente
- âœ… Se necesita abstraer llamadas a API o servicios

### PatrÃ³n de Custom Hook

```jsx
// hooks/useDashboardStats.js
import { useState, useEffect } from 'react'
import { getStatsGlobales } from '../services/api'

/**
 * Hook para obtener y gestionar estadÃ­sticas del dashboard
 * @returns {Object} Estado y funciones relacionadas con estadÃ­sticas
 */
export function useDashboardStats() {
  const [stats, setStats] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    loadStats()
  }, [])

  const loadStats = async () => {
    try {
      setLoading(true)
      setError(null)
      const data = await getStatsGlobales()
      setStats(data)
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }

  return {
    stats,
    loading,
    error,
    refetch: loadStats,
  }
}
```

### Reglas para Hooks

1. **Un hook por archivo**
2. **TamaÃ±o mÃ¡ximo: 200 lÃ­neas**
3. **Responsabilidad Ãºnica**: Un hook debe hacer una cosa
4. **Nombre descriptivo**: Prefijo `use` seguido de propÃ³sito claro

## ğŸ”§ Servicios

### Estructura de Servicios

Los servicios deben:
- âœ… Ser funciones puras o clases con mÃ©todos especÃ­ficos
- âœ… NO tener lÃ³gica de presentaciÃ³n
- âœ… NO tener dependencias de React
- âœ… Retornar datos, no componentes

### PatrÃ³n de Servicio

```jsx
// services/api.js
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL

/**
 * Servicio para obtener estadÃ­sticas globales
 * @returns {Promise<Object>} EstadÃ­sticas del sistema
 */
export async function getStatsGlobales() {
  const response = await fetch(`${API_BASE_URL}/api/admin/stats`)
  
  if (!response.ok) {
    throw new Error('Error al obtener estadÃ­sticas')
  }
  
  return response.json()
}

/**
 * Servicio para obtener estadÃ­sticas de conexiÃ³n
 * @returns {Promise<Object>} EstadÃ­sticas de conexiÃ³n
 */
export async function getConnectionStats() {
  const response = await fetch(`${API_BASE_URL}/api/admin/connection-stats`)
  
  if (!response.ok) {
    throw new Error('Error al obtener estadÃ­sticas de conexiÃ³n')
  }
  
  return response.json()
}
```

### Reglas para Servicios

1. **Un servicio por responsabilidad**
   - `api.js` - Solo llamadas a API REST
   - `auth.js` - Solo autenticaciÃ³n
   - `websocket.js` - Solo WebSocket
2. **TamaÃ±o mÃ¡ximo: 300 lÃ­neas**
3. **Funciones pequeÃ±as**: Cada funciÃ³n debe hacer una cosa
4. **Sin dependencias de UI**: No importar componentes React

## ğŸ› ï¸ Utilidades

### Estructura de Utilidades

Las utilidades deben:
- âœ… Ser funciones puras (sin efectos secundarios)
- âœ… Estar agrupadas por propÃ³sito
- âœ… Ser fÃ¡cilmente testeable
- âœ… No depender de React o servicios externos

### PatrÃ³n de Utilidades

```jsx
// utils/formatters.js
/**
 * Formatea un monto en centavos como moneda venezolana
 * @param {number} amount - Monto en centavos
 * @returns {string} Monto formateado
 */
export function formatCurrency(amount) {
  return new Intl.NumberFormat('es-VE', {
    style: 'currency',
    currency: 'VES',
    minimumFractionDigits: 2,
  }).format(amount / 100)
}

/**
 * Formatea una fecha como string legible
 * @param {Date|string} date - Fecha a formatear
 * @returns {string} Fecha formateada
 */
export function formatDate(date) {
  return new Intl.DateTimeFormat('es-VE', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }).format(new Date(date))
}
```

```jsx
// utils/validators.js
/**
 * Valida que un email tenga formato vÃ¡lido
 * @param {string} email - Email a validar
 * @returns {boolean} true si es vÃ¡lido
 */
export function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email)
}
```

### Reglas para Utilidades

1. **Agrupar por propÃ³sito**: Todas las funciones relacionadas en un archivo
2. **TamaÃ±o mÃ¡ximo: 200 lÃ­neas por archivo de utilidades**
3. **Funciones pequeÃ±as**: Cada funciÃ³n debe ser menor a 50 lÃ­neas
4. **ExportaciÃ³n nombrada**: Usar `export function` en lugar de default

## ğŸ“„ PÃ¡ginas

### Estructura de PÃ¡ginas

Las pÃ¡ginas deben:
- âœ… Ser principalmente componentes de orquestaciÃ³n
- âœ… Usar hooks para lÃ³gica
- âœ… Usar componentes mÃ¡s pequeÃ±os para UI
- âœ… Mantener mÃ­nimo estado local

### PatrÃ³n de PÃ¡gina Modular

```jsx
// pages/Dashboard.jsx
import { useDashboardStats } from '../hooks/useDashboardStats'
import { useWebSocketConnection } from '../hooks/useWebSocketConnection'
import DashboardStats from '../components/dashboard/DashboardStats'
import DashboardConnection from '../components/dashboard/DashboardConnection'
import LoadingSpinner from '../components/ui/LoadingSpinner'
import './Dashboard.css'

/**
 * PÃ¡gina principal del dashboard
 * Componente de orquestaciÃ³n que combina hooks y componentes
 */
function Dashboard() {
  const { stats, loading, error, refetch } = useDashboardStats()
  const { isConnected, connectionStats } = useWebSocketConnection()

  if (loading) {
    return (
      <div className="dashboard-loading">
        <LoadingSpinner />
      </div>
    )
  }

  if (error) {
    return (
      <div className="dashboard-error">
        <p>âŒ Error: {error}</p>
        <button onClick={refetch}>Reintentar</button>
      </div>
    )
  }

  return (
    <div className="dashboard">
      <DashboardStats stats={stats} />
      <DashboardConnection 
        isConnected={isConnected} 
        connectionStats={connectionStats} 
      />
    </div>
  )
}

export default Dashboard
```

### Reglas para PÃ¡ginas

1. **TamaÃ±o mÃ¡ximo: 250 lÃ­neas**
2. **ComposiciÃ³n sobre lÃ³gica**: Usar componentes e hooks, no implementar todo
3. **MÃ­nimo estado local**: Preferir hooks personalizados
4. **Separar estilos**: Cada pÃ¡gina debe tener su archivo CSS

## ğŸ” Checklist de Modularidad

Antes de considerar un archivo completo, verificar:

- [ ] Â¿El archivo tiene menos de 400 lÃ­neas?
- [ ] Â¿Tiene una sola responsabilidad clara?
- [ ] Â¿Se puede describir su propÃ³sito en una oraciÃ³n?
- [ ] Â¿No mezcla lÃ³gica de negocio con presentaciÃ³n?
- [ ] Â¿No tiene mÃ¡s de 3 `useState` o `useEffect` sin extraer a hooks?
- [ ] Â¿Las funciones son pequeÃ±as y tienen un propÃ³sito Ãºnico?
- [ ] Â¿Se puede reutilizar o es especÃ­fico a un caso?

## ğŸš¨ SeÃ±ales de Alarma: CuÃ¡ndo Refactorizar

Refactorizar inmediatamente si observas:

1. **Archivo > 400 lÃ­neas**: Dividir en mÃºltiples archivos
2. **MÃ¡s de 5 `useState`**: Extraer a custom hook o reducer
3. **MÃ¡s de 3 `useEffect`**: Considerar separar lÃ³gica
4. **Funciones > 50 lÃ­neas**: Dividir en funciones mÃ¡s pequeÃ±as
5. **Componente con lÃ³gica de API**: Mover a hook o servicio
6. **MÃºltiples responsabilidades**: Crear archivos separados
7. **CÃ³digo duplicado**: Extraer a utilidad o hook compartido
8. **Imports excesivos**: Indica que el componente hace demasiado

## ğŸ“¦ Proceso de DivisiÃ³n de Archivos

Cuando un archivo supera los lÃ­mites:

1. **Identificar responsabilidades**
   - Listar todas las cosas que hace el archivo
   - Agrupar por responsabilidad

2. **Crear estructura modular**
   - Extraer hooks â†’ `hooks/`
   - Extraer utilidades â†’ `utils/`
   - Extraer componentes â†’ `components/`
   - Extraer servicios â†’ `services/`

3. **Refactorizar paso a paso**
   - Extraer una responsabilidad a la vez
   - Probar despuÃ©s de cada extracciÃ³n
   - Mantener funcionalidad idÃ©ntica

4. **Ejemplo de refactorizaciÃ³n**

```jsx
// âŒ ANTES: Dashboard.jsx (400+ lÃ­neas)
function Dashboard() {
  // Manejo de estado
  const [stats, setStats] = useState(null)
  const [loading, setLoading] = useState(true)
  // ... muchos mÃ¡s estados
  
  // LÃ³gica de carga
  const loadData = async () => { /* ... */ }
  
  // LÃ³gica de WebSocket
  useEffect(() => { /* WebSocket setup */ }, [])
  
  // Formateo
  const formatCurrency = (amount) => { /* ... */ }
  
  // Renderizado
  return (/* Mucho JSX */)
}

// âœ… DESPUÃ‰S: Estructura modular
// Dashboard.jsx (150 lÃ­neas)
import { useDashboardStats } from '../hooks/useDashboardStats'
import { useWebSocketConnection } from '../hooks/useWebSocketConnection'
import DashboardStats from '../components/dashboard/DashboardStats'
import DashboardConnection from '../components/dashboard/DashboardConnection'

function Dashboard() {
  const { stats, loading, error } = useDashboardStats()
  const { isConnected } = useWebSocketConnection()
  
  return (
    <div>
      <DashboardStats stats={stats} />
      <DashboardConnection isConnected={isConnected} />
    </div>
  )
}

// hooks/useDashboardStats.js (80 lÃ­neas)
export function useDashboardStats() { /* ... */ }

// hooks/useWebSocketConnection.js (100 lÃ­neas)
export function useWebSocketConnection() { /* ... */ }

// components/dashboard/DashboardStats.jsx (120 lÃ­neas)
export default function DashboardStats({ stats }) { /* ... */ }

// components/dashboard/DashboardConnection.jsx (100 lÃ­neas)
export default function DashboardConnection({ isConnected }) { /* ... */ }
```

## âœ… Buenas PrÃ¡cticas

1. **Pensar en mÃ³dulos desde el inicio**: DiseÃ±ar con modularidad en mente
2. **Revisar tamaÃ±o frecuentemente**: Verificar lÃ­neas de cÃ³digo regularmente
3. **Refactorizar temprano**: Es mÃ¡s fÃ¡cil cuando el cÃ³digo es pequeÃ±o
4. **Usar herramientas**: ESLint y plugins pueden detectar archivos grandes
5. **Code review enfocado**: Revisar tamaÃ±o y responsabilidades en cada PR
6. **Documentar decisiones**: Si se excede temporalmente, documentar por quÃ© y cuÃ¡ndo refactorizar

## ğŸ“ Convenciones de Nombres

### Archivos y Carpetas

- **Componentes**: PascalCase (`DashboardStats.jsx`)
- **Hooks**: camelCase con prefijo `use` (`useDashboardStats.js`)
- **Servicios**: camelCase (`api.js`, `auth.js`)
- **Utilidades**: camelCase plural (`formatters.js`, `validators.js`)
- **Constantes**: UPPER_SNAKE_CASE en `constants.js`

### Estructura de Importaciones

```jsx
// 1. Imports de React
import { useState, useEffect } from 'react'

// 2. Imports de terceros
import { useNavigate } from 'react-router-dom'

// 3. Imports de componentes locales
import DashboardStats from '../components/dashboard/DashboardStats'

// 4. Imports de hooks
import { useDashboardStats } from '../hooks/useDashboardStats'

// 5. Imports de servicios
import { getStatsGlobales } from '../services/api'

// 6. Imports de utilidades
import { formatCurrency } from '../utils/formatters'

// 7. Imports de constantes
import { API_BASE_URL } from '../utils/constants'

// 8. Imports de estilos
import './Dashboard.css'
```

## ğŸ¯ Resumen de LÃ­mites

| Tipo de Archivo | LÃ­mite Absoluto | LÃ­mite Recomendado |
|----------------|-----------------|-------------------|
| Componente React | 400 lÃ­neas | 250 lÃ­neas |
| PÃ¡gina | 400 lÃ­neas | 250 lÃ­neas |
| Custom Hook | 300 lÃ­neas | 200 lÃ­neas |
| Servicio | 400 lÃ­neas | 300 lÃ­neas |
| Utilidad | 300 lÃ­neas | 200 lÃ­neas |
| FunciÃ³n | 100 lÃ­neas | 50 lÃ­neas |

**Si cualquier archivo supera su lÃ­mite absoluto, DEBE dividirse inmediatamente.**
